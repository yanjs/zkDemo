import "hashes/sha256/512bitPadded" as sha256;
from "./Add" import add;
from "./Cmp" import cmp;
from "./Config" import N_MIX;
from "./Contains" import contains;

const u32 N_MERGE = 2;

def main(\
    u32[N_MERGE][8] nullifiers, /* input */ \
    u32[N_MIX][8] mixed_note_ids, /* input */ \
    u32[8] new_note_id, /* output */ \
    private u32[N_MERGE][8] secrets, /* input */ \
    private u32[N_MERGE][8] note_ids, /* input */ \
    private u32[N_MERGE][8] amts, /* input */ \
    private u32[8] new_note_l /* output */ \
) {
    u32[8] zero = [0;8];
    u32[8] one = [0,0,0,0,0,0,0,1];
    // assert amt > 0
    for u32 i in 0..N_MERGE {
        assert(cmp(amts[i], zero) != 0);
    }

    // assert note_id in mixed_note_ids
    for u32 i in 0..N_MERGE {
        assert(contains(mixed_note_ids, note_ids[i]));
    }

    // assert note_id == sha256(secret, amt)
    for u32 i in 0..N_MERGE {
        u32[8] exp_note_l = sha256(secrets[i], one);
        u32[8] exp_note_id = sha256(exp_note_l, amts[i]);
        assert(exp_note_id == note_ids[i]);
    }

    // assert sum(...) = new amt
    u32[8] mut sum = [0;8];
    for u32 i in 0..N_MERGE {
        sum = add(sum, amts[i]);
    }

    // assert nullifier == sha256(secret, 0)
    for u32 i in 0..N_MERGE {
        u32[8] exp_note_nullifier = sha256(secrets[i], zero);
        assert(exp_note_nullifier == nullifiers[i]);
    }

    // assert new_note_id = sha256(new_note_l, amt)
    u32[8] exp_new_note_id = sha256(new_note_l, sum);
    assert(new_note_id == exp_new_note_id);

    return;
}