import "hashes/sha256/512bitPadded" as sha256;
from "./Add" import add;
from "./Cmp" import cmp;
from "./Config" import N_MIX;
from "./Contains" import contains;

const u32 N_SPLIT = 2;

def main(\
    u32[8] nullifier, /* input */ \
    u32[N_MIX][8] mixed_note_ids, /* input */ \
    u32[N_SPLIT][8] new_note_ids, /* output */ \
    private u32[8] secret, /* input */ \
    private u32[8] note_id, /* input */ \
    private u32[N_SPLIT][8] new_note_ls, /* output */ \
    private u32[N_SPLIT][8] amts /* output */ \
) {
    u32[8] zero = [0;8];
    u32[8] one = [0,0,0,0,0,0,0,1];
    // assert amt > 0
    for u32 i in 0..N_SPLIT {
        assert(cmp(amts[i], zero) != 0);
    }

    // assert note_id in mixed_note_ids
    assert(contains(mixed_note_ids, note_id));

    // assert note_id == sha256(secret, amt)
    u32[8] mut sum = [0;8];
    for u32 i in 0..N_SPLIT {
        sum = add(sum, amts[i]);
    }
    u32[8] exp_note_l = sha256(secret, one);
    u32[8] exp_note_id = sha256(exp_note_l, sum);
    assert(exp_note_id == note_id);

    // assert nullifier == sha256(secret, 0)
    u32[8] exp_nullifier = sha256(secret, zero);
    assert(exp_nullifier == nullifier);

    // assert new_note_ids = sha256(new_note_ls, amt)
    for u32 i in 0..N_SPLIT {
        u32[8] exp_new_note_id = sha256(new_note_ls[i], amts[i]);
        assert(exp_new_note_id == new_note_ids[i]);
    }

    return;
}